# キーボードでキャラクターを動かす
操作ができないゲームはただの映画です。
ただの映画にしてはあまりにも画像のクオリティーが低いので、頑張ってキャラクター
を動かせるようにしましょう。
この辺から少しむずかしくなりますが、習うより慣れろ精神でどんどん読み進めることを
おすすめします。
ちなみにこの章で「イベント処理」と「if文」、「配列」および「関数」を説明します。

## イベントを補足する
ユーザーがキーボードを叩いたり、マウスをクリックしたり、幼馴染の女子高生が大学生
の彼氏を作ったという話を聞くと**イベント**というものが発生します。
したがって、この**イベント**が発生したことを補足できれば様々な局面に対応できます。

まぁとりあえずイベントの説明はこの辺にして、コードを見てみましょう。
以下のように `shooting.js` を修正してください。

```javascript
// ...

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // キーボードが押されるとこの内部の処理が実行される
    console.log("キーボードが押されたよ");
};

// ページロード時に呼び出される処理を指定
window.onload = function() {
    // ...
};
```

これを実行するとキーボード入力時に「キーボードが押されたよ」と表示されると思い
ます。
なお、うまく動かない場合は一度マウスでバグをクリックしてください（デベロッパー
ツールにフォーカスが取られているとうまく動作しないため）。

## 押されたキーを取得する
キーが押されたことだけがわかってもゲームが成り立つとは思えません。
したがって「どのキーが押されたのか？」が分かる必要があります。
これは `e.keyCode` とすると取得できます。
下記コードを参照して書き換えてください。

```javascript
// ...

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // キーボードが押されるとこの内部の処理が実行される
    console.log(e.keyCode + "番のキーが押されたよ");
};

// ページロード時に呼び出される処理を指定
window.onload = function() {
    // ...
};
```

キーを入力した際に「83番のキーが押されたよ」のように番号が表示されれば成功です。
各キーには固有の番号がふられているのでゲームで使用するキー番号はメモしておきま
しょう。

なお日本語入力がONになっていると動かないので注意してください。


## もしも〜なら〜する（if文）
さて、押されたキーを判別することができたので、ナニが押されたか？
に対して処理を分けることが出来ればキャラクターを動かせそうなもんです。
この「もしも〜なら〜する」という処理は**if文**というものを使えば行えます。
この**if文**ですが、構文は下記のようになっています。

```javascript
// 条件が1つの場合
if(条件式）{
    条件が正しい場合実行されるコード
}

// 条件が1つの場合2
if(条件式）{
    条件が正しい場合実行されるコード
} else {
    条件が正しく無いときに実行されるコード
}

// 条件が2つ以上の場合
if(条件式1）{
    条件が正しい場合実行されるコード
} else if(条件式2） {
    条件式1が正しくなく、条件式2が正しい場合に実行されるコード
} else {
    すべての条件が正しくない場合に実行されるコード
}
```

さて、ここで**条件式**というのが出てきました。
**条件式**とは、なんとも説明がしがたいのですが下記のようなものを言います。

```javascript
A == B // A と B が等しい（=は2つなので注意！）
A != B // A と B が等しくない
A >= B // A は B と等しいか大きい
A <= B // A は B と等しいか小さい
A > B  // A は B より大きい
A < B  // A は B より小さい
```

おそらく数学で習ったと思います。
ただ**プログラミングの等しいは `==` で表されることにむっちゃ注意（`=` は代入）**。
結構この辺のミスが多いと思います。

さて、この**if文**と**条件式**を駆使してプログラマは処理を分けていきます。
では実際に**スペースが押された時だけ「スペースが押されたよ」と表示してみましょう**。
以下のように `shooting.js` を書き換えてください。

```javascript
// ...

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // スペース（32番）が押されたか確かめる
    if(e.keyCode == 32) {
        // keyCodeが32の時だけ実行される部分
        console.log("スペースキーが押されたよ");
    } else {
        // スペースキー以外の場合は単純に番号を表示
        console.log(e.keyCode + "番のキーが押されたよ");
    }
};

// ページロード時に呼び出される処理を指定
window.onload = function() {
    // ...
};
```

スペースキーを押した時と他のキーを押した時で表示される内容が変化していれば
成功です。

## プレイヤーを動かしてみる
だいたい準備はそろったので、そろそろプレイヤーを動かすことを考えます。

### 動くってナニ？
まず「動く」ってなんだ？というところをちょっと考えてみましょう。
現実世界では「動く」というのは物理的な位置が変わることを指します。
ただ、今はコンピュータの画面上に描画されたキャラクターが動くかどうかの議論なので
これは違います（物理的に動かすってことは画面を持って走るってことですよね？）。

まぁ結論を述べると、コンピューター上に描画されたキャラクターが動くというのは
「今現在の描画が消され、少し離れた位置に新しく描画される」ということです。
なんだか難しい話に聞こえますが、ようは「パラパラアニメ」です。

要点をまとめると、キャラクターを動かすためには

1.  現在の描画を消す
2.  少し離れた位置に再度描画する

となります。
ではこれを実際に行なってみましょう。

### 現在位置を定義する
「少し離れた場所」というのを知るためには「今現在どこにいるか？」がわからなくては
なりません。
したがって、今現在のプレイヤーの位置を保存しておく変数を定義します。
描画はこの変数の値を使用して行い、プレイヤーを移動させる場合はこの変数の値を
少し増やせば（減らせば）良いことになります。

ではプレイヤーの位置を保存する変数を定義して、その変数を用いて描画するように
書き換えてみましょう。
`shooting.js` を以下のようにしてください。

```javascript
"use strict"
// 全体で使用する変数を定義
var canvas, ctx;
// プレイヤーの画像を保持する変数を定義
var img_player;
// 敵キャラの画像を保持する変数を定義
var img_enemy;
// プレイヤーの現在位置を保持する変数を定義
// player_x -- プレイヤーのx座標
// player_y -- プレイヤーのy座標
var player_x, player_y;

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // ...
};

// ページロード時に呼び出される処理を指定
window.onload = function() {
    // ...

    // Playerの初期位置を指定
    // player_x = キャンバスの左右中央
    // player_y = キャンバスの下から20px上
    player_x = (canvas.width - player.width) / 2;
    player_y = (canvas.height -player.height) - 20;

    // Playerの画像を (player_x, player_y) の位置に描画
    ctx.drawImage(img_player, player_x, player_y);
    // 敵キャラの画像をランダムな位置に表示
    for(var i=0; i<10; i++) {
        ctx.drawImage(img_enemy,
                    Math.random() * (canvas.width - img_enemy.width),
                    Math.random() * (canvas.height - img_enemy.height));
    }
};
```

ついでにプレイヤーの初期位置をシューティングゲームっぽい位置に設定しました。
実行した際にキャンバスの左右中央下の方にプレイヤーが表示されていれば成功です。

### プレイヤーを動かす
プレイヤーの「現在位置」が定義できたので次は右矢印キーが入力された時にプレイヤー
を右に動かすようにしてみましょう。
これはどのように行うかというと

1.  キー入力を取得
2.  右矢印キーか判定
3.  プレイヤーの現在位置を少し右にずらす
4.  キャンバスをクリアする
5.  プレイヤーを新しい現在位置に描画する

というステップになります。
では下記を参考に `shooting.js` を書き換えてください。

```javascript
// ...

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // 右矢印（39番）が押されたか確かめる
    if(e.keyCode == 39) {
        // プレイヤーのx座標を少し増やす
        //   XXX += 2 という書き方は XXX = XXX + 2 を短くした書き方
        player_x += 2;

        // キャンバスをクリアする
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 新しい位置にプレイヤーを描画
        ctx.drawImage(img_player, player_x, player_y);
    }
};

// ...
```

これを実行して右矢印キーを押すと敵キャラがすべて消えて（キャンバスをクリアした
ため）、プレイヤーが右に移動します。

同様にして左右に動くようにもしてみましょう（上下左右でもいいのですが、ゲームの
特性上左右だけのほうがゲームっぽくなるので今回は左右だけです）。
コードはほぼ同じなのでご自身で行なってみてください。
下記に各矢印キーの番号を明記します。

-   左矢印キー: 37
-   右矢印キー: 39

念の為僕のコードも貼り付けておきます。
うまく動かない場合は参考にしてください。
また、`if` と `else if` の使い分けや、どのようにして同じ処理を繰り返し書かない
ようにしているか、どうすればコードがわかりやすくなるのか？などに注意してみてく
ださい。

```javascript
// ...

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // 上下左右の移動速度を定義
    var SPEED = 2;

    // キー番号だとわかりにくいため予め変数に格納
    var RIGHT = 39;
    var LEFT  = 37;

    // 移動処理を行ったかどうか（Yes/No）を表す変数を定義し
    // 移動していない（false）で初期化
    var moved = false;

    if(e.keyCode == RIGHT) {
        // プレイヤーのx座標を少し増やす
        player_x += SPEED;
        // 移動したので true を代入
        moved = true;
    } else if(e.keyCode == LEFT) {
        // プレイヤーのx座標を少し減らす
        player_x -= SPEED;
        // 移動したので true を代入
        moved = true;
    }

    // キー入力により移動したか調べる
    // 注意: 真偽値なので moved == true のようにしなくても同じ意味になる
    if(moved) {
        // キャンバスをクリアする
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 新しい位置にプレイヤーを描画
        ctx.drawImage(img_player, player_x, player_y);
    }
};

// ...
```

## 敵キャラを消えないようにする（配列を使用）
プレイヤーは左右に動くようになりましたが、敵キャラが消えてしまいます。
もちろん敵キャラも再描画するようにすればいいのですが、素直に下記のようにすると
敵キャラの位置が毎回変わってしまいます。

```javascript
// ...

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // ...

    // キー入力により移動したか調べる
    // 注意: 真偽値なので moved == true のようにしなくても同じ意味になる
    if(moved) {
        // キャンバスをクリアする
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 新しい位置にプレイヤーを描画
        ctx.drawImage(img_player, player_x, player_y);

        // 敵キャラの画像をランダムな位置に表示
        // これだとプレイヤーが動くたびに敵キャラの位置が変わってしまう
        for(var i=0; i<10; i++) {
            ctx.drawImage(img_enemy,
                          Math.random() * (canvas.width - img_enemy.width),
                          Math.random() * (canvas.height - img_enemy.height));
        }
    }
};

// ...
```

したがって敵キャラの位置もプレイヤーのように変数で保存する必要があるのですが、
敵キャラはプレイヤーと違って10匹もいます。
プレイヤーの場合と同様に変数を定義すると、下記のように非常に面倒くさいことに
なります。

```javascript
// 敵キャラの現在位置を保持する変数を定義？？？面倒くさ過ぎない？
var enemy_1_x, enemy_1_y;
var enemy_2_x, enemy_2_y;
// ...
var enemy_10_x, enemy_10_y;
```

さて、こういう場合に**「配列」**を使うと非常にスッキリと書けます。
**「配列」**の中には変数がたくさん入っています。
中の変数には**添字**と呼ばれる番号でアクセスできるため**for文**で使用する
カウンター変数（`i`）などで簡単に個々の変数にアクセスできます。
以下例です。

```javascript
// 配列を格納する変数 a を定義
var a;
// a に100個の要素を持つ配列を代入
a = new Array(100);
// a の各要素に数字を代入
// なお a.length は要素数（100）を返す
for(var i=0; i<a.length; i++) {
    // i 番目の要素に自分の番目（i）を代入
    a[i] = i;
}
```

これを使用すれば1000匹だろうが10000匹だろうが手間はそれほど変わりません。
以下のように `shooting.js` を編集してください。

```javascript
"use strict"
// 全体で使用する変数を定義
var canvas, ctx;
// 敵キャラの数を定義
var ENEMIES = 10;
// ...
var player_x, player_y;
// 敵キャラの現在位置（配列）を保持する変数を定義し
// ENEMIES分だけ要素数を持つ配列を代入
var enemies_x = new Array(ENEMIES);
var enemies_y = new Array(ENEMIES);

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // ...

    // キー入力により移動したか調べる
    // 注意: 真偽値なので moved == true のようにしなくても同じ意味になる
    if(moved) {
        // キャンバスをクリアする
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 新しい位置にプレイヤーを描画
        ctx.drawImage(img_player, player_x, player_y);

        // 敵キャラの画像を (enemies_x[i], enemies_y[i]) の位置に表示
        for(var i=0; i<ENEMIES; i++) {
            ctx.drawImage(img_enemy, enemies_x[i], enemies_y[i]);
        }
    }
};

// ページロード時に呼び出される処理を指定
window.onload = function() {
    // ...

    // 敵キャラの初期位置を指定
    for(var i=0; i<ENEMIES; i++) {
        enemies_x[i] = Math.random() * (canvas.width - img_enemy.width);
        enemies_y[i] = Math.random() * (canvas.height - img_enemy.height);
    }

    // Playerの画像を (player_x, player_y) の位置に描画
    ctx.drawImage(img_player, player_x, player_y);
    // 敵キャラの画像を (enemies_x[i], enemies_y[i]) の位置に表示
    for(var i=0; i<ENEMIES; i++) {
        ctx.drawImage(img_enemy, enemies_x[i], enemies_y[i]);
    }
};
```

これを実行してプレイヤーを動かしてみてください。
敵キャラが消えたり毎度場所が変わったりしなければ成功です。

## 描画処理を関数化する
プレイヤーと敵キャラの描画はページロード時処理とキー入力処理の部分で全く同じ
コードをコピペして使用しています。
このように全く同じ処理（もしくはひどく似た処理）は**「関数化」**することで
もっとシンプルに行えるようになります。
この先コードがどんどん複雑になることが予想できるので、この辺でコードをシンプルに
するための**「関数化」**を行いましょう。

**関数**とは「ある値を受け取り、ある値を返すもの」です。
別な言い方をすると「ある処理をまとめたもの」です。
例えば、普段良く使用する「掛け算」も関数の一例です。
何故ならば「掛け算」とは「2つの数値 a, b をとり a を b個足した数を返すもの」と
言う事ができるからです。

では**関数**の定義の仕方と具体的な使用例を見てみましょう。

```javascript
// 関数の定義（引数（ひきすう）は任意の数取れる。また値は返さなくても良い）
var 関数名 = function(引数1, 引数2, ...) {
    処理
    return 戻り値（返す値）;
};

// 掛け算の場合（引数をとり、値を返す関数）
var multiple = function(a, b) {
    // 結果を代入する変数を定義し0で初期化
    var result = 0;
    // b個分ループする
    for(var i=0; i<b; i++) {
        // 結果に a を足す
        result += a;
    }
    // 最終的な結果を返す
    return result;
};
// 掛け算の使い方
console.log(multiple(2, 3));
// 出力: 6
        
// 掛け算結果を表示する関数（引数をとり、値を返さない関数）
var multipleDisplay = function(a, b) {
    // 先ほど作った multiple 関数を使用して結果を計算し代入する
    var result = multiple(a, b);
    // 結果を表示する（値は返さない）
    console.log(result);
};
// 使い方
multipleDisplay(2, 3);
// 出力: 6

// 2 x 3 を返す関数（引数を取らず、値を返す関数）
var twoTimesThree = function() {
    // 先ほど作った multiple 関数を使用して結果を計算し代入する
    var result = multiple(2, 3);
    // 最終的な結果を返す（返さないで表示しても良い）
    return result;
};
// 使い方
console.log(twoTimesThree());
// 出力: 6
```

この**関数**を使用して描画部分を共通化しましょう。
下記のように `shooting.js` を修正してください。

```javascript
// ...

// 再描画する関数（無引数、無戻り値）
var redraw = function() {
    // キャンバスをクリアする
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 新しい位置にプレイヤーを描画
    ctx.drawImage(img_player, player_x, player_y);

    // 敵キャラの画像を (enemies_x[i], enemies_y[i]) の位置に表示
    for(var i=0; i<ENEMIES; i++) {
        ctx.drawImage(img_enemy, enemies_x[i], enemies_y[i]);
    }
};

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // ...

    // キー入力により移動したか調べる
    // 注意: 真偽値なので moved == true のようにしなくても同じ意味になる
    if(moved) {
        // 再描画する
        redraw();
    }
};

// ページロード時に呼び出される処理を指定
window.onload = function() {
    // ...

    // 敵キャラの初期位置を指定
    for(var i=0; i<ENEMIES; i++) {
        enemies_x[i] = Math.random() * (canvas.width - img_enemy.width);
        enemies_y[i] = Math.random() * (canvas.height - img_enemy.height);
    }

    // (再)描画する
    redraw();
};
```

このように関数を定義すると繰り返し行う処理や、あちこちで行なっている共通した処理
を一箇所にまとめることができ便利です。
また、このように処理を1箇所にまとめることで修正を行う箇所を限定できるのでバグが
発生しづらく、修正も楽に行えます。

