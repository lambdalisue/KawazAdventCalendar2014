# 滑らかにプレイヤーを動かす
ここまでで、プレイヤーを自由自在に動かすことが出来るようになりましたが、下記の
点で不満が残ります。

1.  移動がなんとなくカクカクしている
2.  上と右を入力した時にどちらかにしか移動できない（斜め移動ができない）

この章では一般的なゲームで使用されている**メインループ**を用いてこれらの問題点
を解決する方法を解説します。

## なぜ滑らかに動かないのか
先の移動処理は簡略化すると以下のようなステップで行われていました。

1.  ユーザーがキーを入力する
2.  ブラウザがキー入力を察知し、`onkeydown` イベントを発生させる
3.  `onkeydown` イベントに渡されたキー情報を元にプレイヤーを移動させる

このように**イベント**が発生した段階で処理を走らせる形式をここでは
**イベント駆動方式**と呼ぶことにします。
対照的に、一般的なゲームでは下記のように移動処理を行なっています。

1.  キーボードの状態を調べる
2.  キーが入力されていた場合はプレイヤーを移動させる
3.  最初に戻る

これらの処理に当たり判定や描画処理などを加えたものを**メインループ**と呼びます。
なお、これら全体の処理はゲーム種により違いはありますが、たいていミリ秒単位で行
われます（60 FPS のゲームの場合約 17 ms）。

一方、イベント駆動方式の場合ユーザーがキーを押しっぱなしにするとOSが自動的に
一定の速度でキーを連打します（そのため KeyDown イベントなのに押しっぱなしでも
連続的に呼ばれる）。
この連打の速度はOSの設定などにより違いますが、メモ帳などで `a` キーを押し続けた
時に `a` が入力される速度と等しいのですごく遅いです。
したがってイベント駆動方式でキー入力処理を行なっている今作成中のゲームは動きが
カクカクしています。

また、捕捉ですが `onkeydown` イベントはあくまでもキーが押されたことを通知する
イベントなので同時押しに対応していません（e.keyCodeには1つのキーを表す番号しか
反映されていない）。
そのため斜め移動など、同時に複数のキーの入力を取得しなければいけない処理はできま
せん。

## メインループ方式に変更する
ストレスが無いゲームを作成するためにはメインループ方式に移行する以外手段は
ありません。
このメインループ方式ですが、名前の通り通常は**無限ループ**を用いて下記のように
記載します。

```javascript
// for(;;){} で無限ループになる（ただしブラウザが固まるので実用性はない）
for(;;) {
    // メインループ処理
}
```

ただし、コメントにも書きましたがJavaScriptではブラウザが固まってしまうためこの
方法は取れません（C/C++など、別言語ならばOSに処理を戻す処理を記載出来るため
フリーズが避けられる）。

そのため仮想的にこのメインループを実装するために **`setTimeout`** というタイマー
を利用します。

`setTimeout` は関数と時間を受け取り、渡された関数を渡された時間後に実行する関数
です。
したがって、以下のようにすると無限ループを作ることができます（馴れないと何故無限
ループするのか理解に苦しむかもしれませんが）。

```javascript
// 無限ループする関数を定義
var infinityLoop = function() {
    // コンソールに出力
    console.log("ループ中");
    // 1000ミリ秒後に infinityLoop（この関数）を実行
    setTimeout(infinityLoop, 1000);
};
// infinityLoopを実行（無限ループ開始）
infinityLoop();
```

ただし、このままだと**実行環境によってゲーム速度が変化します**。
コンピュータのスペックは個々で異なるのでメインループを処理できる時間も異なります。
この違いを可能な限り小さくするためにFPS（frame per second）制御と呼ばれるゲーム
時間の制御を行う必要があります。

FPS制御の仕組みは以下のとおりです。

1.  フレーム開始時間を取得
2.  フレーム処理を行う
3.  フレーム処理終了時間を取得
4.  開始・終了時間からフレーム処理に何秒かかったのかを計算
5.  大抵の場合処理が早すぎるので一定のFPSになるように待つ

この処理をさきほどの `setTimeout` と組み合わせるとJavaScriptでメインループ方式
を使うことができます。
とりあえずキー入力によりプレイヤーの操作は後回しにするので、下記のように
`shooting.js` を修正しメインループ方式に変更してください。

```javascript
"use strict"
// 全体で使用する変数を定義
var canvas, ctx;
// FPS管理に使用するパラメータを定義
var FPS = 30;
var MSPF = 1000 / FPS;
// ...

// メインループを定義
var mainloop = function() {
    // 処理開始時間を保存
    var startTime = new Date();

    // 描画処理
    redraw();

    // 処理経過時間および次のループまでの間隔を計算
    var deltaTime = (new Date()) - startTime;
    var interval = MSPF - deltaTime;
    if(interval > 0) {
        // 処理が早すぎるので次のループまで少し待つ
        setTimeout(mainloop, interval);
    } else {
        // 処理が遅すぎるので即次のループを実行する
        mainloop();
    }
};

// 下記は不適とわかったためコメントアウトしている（消しても構わない）
// キーが押された時に呼び出される処理を指定
//window.onkeydown = function(e) {
//  // ...
//};

// ページロード時に呼び出される処理を指定
window.onload = function() {
    // ...

    // 敵キャラの初期位置を指定
    for(var i=0; i<ENEMIES; i++) {
        enemies_x[i] = Math.random() * (canvas.width - img_enemy.width);
        enemies_y[i] = Math.random() * (canvas.height - img_enemy.height);
    }

    // メインループを開始する
    mainloop();
};
```

まだなにも動かないので正しくメインループ方式に移行できたかわかりません。
とりあえず次に進みましょう。

## キーボードの状態を取得する
メインループ方式に変更したため、今までのようにイベントでキーの入力状態を取得する
方法は使えません。
しかしJavaScriptには現在のキーの状態を取得する方法がありません。
したがって `onkeydown` と `onkeyup` イベントを用いて自分で現在のキー状態を管理
します。

`onkeyup` イベントはキーが離された時に発生します。
キーが押された時に発生する `onkeydown` イベントとちょうど反対の役割をします。
したがって全キーの状態を配列で保持し `onkeydown` イベントでその配列の `e.keyCode`
番目を `true` にし `onkeyup` イベントで `false` にすればすべてのキーの状態を
配列で保持できます。
まずは以下のようにキー状態の保存変数の定義とイベントによる状態更新のコードを
`shooting.js` に加えてください。
なおメインループ方式に変更した際にコメントアウトした部分（`window.onkeydown`）
は今回のコードとバッティングするので削除してください。

```javascript
"use strict"
// 全体で使用する変数を定義
var canvas, ctx;
// FPS管理に使用するパラメータを定義
var FPS = 30;
var MSPF = 1000 / FPS;
// キー状態管理変数の定義（確か256以上のキーコードは無いと思う…ちょっと怪しい）
var KEYS = new Array(256);
// キーの状態を false （押されていない）で初期化
for(var i=0; i<KEYS.length; i++) {
    KEYS[i] = false;
}

// ...

// メインループを定義
var mainloop = function() {
    // ...
};

// キーが押された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // キーを押された状態に更新
    KEYS[e.keyCode] = true;
}
// キーが離された時に呼び出される処理を指定
window.onkeydown = function(e) {
    // キーを離された状態に更新
    KEYS[e.keyCode] = false;
}

// ページロード時に呼び出される処理を指定
window.onload = function() {
    // ...
};
```

これでどこでも `KEYS[キー番号]` のようにすれば、そのキーが押されていれば `true`
押されていなければ `false` と入力状態が取得できるようになりました。


## プレイヤーを滑らかに動かす
これですべての準備が整ったので、再度プレイヤーを動かすコードを書きましょう。
今回はメインループから呼び出すので `movePlayer()` という関数を定義し、その中
にプレイヤーの移動処理を記載しました。
下記を参考にして `shooting.js` を修正してください。

```javascript
// ...

// プレイヤーの移動処理を定義
var movePlayer = function() {
    // 上下左右の移動速度を定義
    var SPEED = 2;

    // キー番号だとわかりにくいため予め変数に格納
    var RIGHT = 39;
    var LEFT  = 37;

    if(KEYS[RIGHT]) {
        // プレイヤーのx座標を少し増やす
        player_x += SPEED;
    }
    if(KEYS[LEFT]) {
        // プレイヤーのx座標を少し減らす
        player_x -= SPEED;
    }
};

// メインループを定義
var mainloop = function() {
    // 処理開始時間を保存
    var startTime = new Date();

    // プレイヤーの移動処理
    movePlayer();

    // 描画処理
    redraw();

    // 処理経過時間および次のループまでの間隔を計算
    var deltaTime = (new Date()) - startTime;
    var interval = MSPF - deltaTime;
    if(interval > 0) {
        // 処理が早すぎるので次のループまで少し待つ
        setTimeout(mainloop, interval);
    } else {
        // 処理が遅すぎるので即次のループを実行する
        mainloop();
    }
};

// ...
```

カクカクがなくなったことに気づけましたか？

## プレイヤーの移動範囲を制限する
今のままだとプレイヤーはキャンバスの外にも移動できてしまいます。
これじゃゲームにならないのでプレイヤーの移動可能範囲を制限しましょう。
仕組みは簡単で、プレイヤーのx座標によって移動できるかを決定します。
またもしもプレイヤーがキャンバスの外にはみ出ていた場合は強制的に中に戻してやり
ます。

下記コードを参考に `shooting.js` を修正してください。

```javascript
// ...

// プレイヤーの移動処理を定義
var movePlayer = function() {
    // 上下左右の移動速度を定義
    var SPEED = 2;

    // キー番号だとわかりにくいため予め変数に格納
    var RIGHT = 39;
    var LEFT  = 37;

    if(KEYS[RIGHT] && player_x+img_player.width < canvas.width) {
        // プレイヤーのx座標を少し増やす
        player_x += SPEED;
    }
    if(KEYS[LEFT] && player_x > 0) {
        // プレイヤーのx座標を少し減らす
        player_x -= SPEED;
    }

    // プレイヤーがはみ出てしまった場合は強制的に中に戻す
    if(player_x < 0) {
        player_x = 0;
    } else if (player_x + img_player.width > canvas.width) {
        player_x = canvas.width - img_player.width;
    }
};
// ...
```

なお条件式で使用している `&&` は論理演算子とゆうもので日本語で言う「かつ」
を表します。
したがってプレイヤーがキャンバス内にいる場合のみキーの入力を受け付け、
またプレイヤーがはみ出てしまった場合は強制的にキャンバス内に戻しています。

